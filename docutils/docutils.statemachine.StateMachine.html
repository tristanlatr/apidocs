<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>docutils.statemachine.StateMachine : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header navbar-brand">
          <a href="https://github.com/tristanlatr/apidocs/tree/main">docutils-0.17.1</a>
          <a href="index.html">API Documentation</a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="docutils.html">docutils</a></code>.<code><a href="docutils.statemachine.html">statemachine</a></code>.<code><a href="docutils.statemachine.StateMachine.html">StateMachine</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">StateMachine</span>(<span title="object">object</span>):</code></p><p>Known subclasses: <code><a href="docutils.statemachine.SearchStateMachine.html">docutils.statemachine.SearchStateMachine</a></code>, <code><a href="docutils.statemachine.StateMachineWS.html">docutils.statemachine.StateMachineWS</a></code></p>
        <p><a href="classIndex.html#docutils.statemachine.StateMachine">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>A finite state machine for text filters using regular expressions.</p>
<p>The input is provided in the form of a list of one-line strings (no
newlines). States are subclasses of the <code><a href="docutils.statemachine.State.html">State</a></code> class. Transitions consist
of regular expression patterns and transition methods, and are defined in
each state.</p>
<p>The state machine is started with the <code>run()</code> method, which returns the
results of processing in a list.</p>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id706">
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__init__">__init__</a></code></td>
    <td><span>Initialize a <code><a href="docutils.statemachine.StateMachine.html">StateMachine</a></code> object; add state objects.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#input_lines">input_lines</a></code></td>
    <td><span><code><a href="docutils.statemachine.StringList.html">StringList</a></code> of input lines (without newlines). Filled by <code>self.run()</code>.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#input_offset">input_offset</a></code></td>
    <td><span>Offset of <code>self.input_lines</code> from the beginning of the file.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#line">line</a></code></td>
    <td><span>Current input line.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#line_offset">line_offset</a></code></td>
    <td><span>Current input line offset from beginning of <code>self.input_lines</code>.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#debug">debug</a></code></td>
    <td><span>Debugging mode on/off.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#initial_state">initial_state</a></code></td>
    <td><span>The name of the initial state (key to <code>self.states</code>).</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#current_state">current_state</a></code></td>
    <td><span>The name of the current state (key to <code>self.states</code>).</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#states">states</a></code></td>
    <td><span>Mapping of {state_name: State_object}.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><code><a href="#observers">observers</a></code></td>
    <td><span>List of bound methods or functions to call whenever the current line changes.  Observers are called with one argument, <tt class="rst-docutils literal">self</tt>. Cleared at the end of <code>run()</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#unlink">unlink</a></code></td>
    <td><span>Remove circular references to objects no longer required.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#run">run</a></code></td>
    <td><span>Run the state machine on <code><a href="#input_lines">input_lines</a></code>. Return results (a list).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_state">get_state</a></code></td>
    <td><span>Return current state object; set it first if <code>next_state</code> given.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#next_line">next_line</a></code></td>
    <td><span>Load <code>self.line</code> with the <code>n</code>'th next line and return it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_next_line_blank">is_next_line_blank</a></code></td>
    <td><span>Return 1 if the next line is blank or non-existant.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#at_eof">at_eof</a></code></td>
    <td><span>Return 1 if the input is at or past end-of-file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#at_bof">at_bof</a></code></td>
    <td><span>Return 1 if the input is at or before beginning-of-file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#previous_line">previous_line</a></code></td>
    <td><span>Load <code>self.line</code> with the <code>n</code>'th previous line and return it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#goto_line">goto_line</a></code></td>
    <td><span>Jump to absolute line offset <code><a href="#line_offset">line_offset</a></code>, load and return it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_source">get_source</a></code></td>
    <td><span>Return source of line at absolute line offset <code><a href="#line_offset">line_offset</a></code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#abs_line_offset">abs_line_offset</a></code></td>
    <td><span>Return line offset of current line, from beginning of file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#abs_line_number">abs_line_number</a></code></td>
    <td><span>Return line number of current line (counting from 1).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_source_and_line">get_source_and_line</a></code></td>
    <td><span>Return (source, line) tuple for current or given line number.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#insert_input">insert_input</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_text_block">get_text_block</a></code></td>
    <td><span>Return a contiguous block of text.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#check_line">check_line</a></code></td>
    <td><span>Examine one line of input for a transition match &amp; execute its method.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_state">add_state</a></code></td>
    <td><span>Initialize &amp; add a <code>state_class</code> (<code><a href="docutils.statemachine.State.html">State</a></code> subclass) object.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_states">add_states</a></code></td>
    <td><span>Add <code><a href="docutils.parsers.rst.states.html#state_classes">state_classes</a></code> (a list of <code><a href="docutils.statemachine.State.html">State</a></code> subclasses).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#runtime_init">runtime_init</a></code></td>
    <td><span>Initialize <code>self.states</code>.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#error">error</a></code></td>
    <td><span>Report error details.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#attach_observer">attach_observer</a></code></td>
    <td><span>The <code>observer</code> parameter is a function or bound method which takes two arguments, the source and offset of the current line.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#detach_observer">detach_observer</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#notify_observers">notify_observers</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_stderr">_stderr</a></code></td>
    <td><span>Wrapper around sys.stderr catching en-/decoding errors</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__init__</span>(self, state_classes, initial_state, debug=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Initialize a <code><a href="docutils.statemachine.StateMachine.html">StateMachine</a></code> object; add state objects.</p>
<p>Parameters:</p>
<ul class="rst-simple">
<li><code><a href="docutils.parsers.rst.states.html#state_classes">state_classes</a></code>: a list of <code><a href="docutils.statemachine.State.html">State</a></code> (sub)classes.</li>
<li><code><a href="#initial_state">initial_state</a></code>: a string, the class name of the initial state.</li>
<li><code><a href="#debug">debug</a></code>: a boolean; produce verbose output if true (nonzero).</li>
</ul>
</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.input_lines">
    
  </a>
  <a name="input_lines">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">input_lines</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><code><a href="docutils.statemachine.StringList.html">StringList</a></code> of input lines (without newlines).
Filled by <code>self.run()</code>.</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.input_offset">
    
  </a>
  <a name="input_offset">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">input_offset</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>Offset of <code>self.input_lines</code> from the beginning of the file.</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.line">
    
  </a>
  <a name="line">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">line</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>Current input line.</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.line_offset">
    
  </a>
  <a name="line_offset">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">line_offset</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>Current input line offset from beginning of <code>self.input_lines</code>.</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.debug">
    
  </a>
  <a name="debug">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">debug</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>Debugging mode on/off.</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.initial_state">
    
  </a>
  <a name="initial_state">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">initial_state</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>The name of the initial state (key to <code>self.states</code>).</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.current_state">
    
  </a>
  <a name="current_state">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">current_state</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>The name of the current state (key to <code>self.states</code>).</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.states">
    
  </a>
  <a name="states">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">states</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>Mapping of {state_name: State_object}.</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="docutils.statemachine.StateMachine.observers">
    
  </a>
  <a name="observers">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">observers</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>List of bound methods or functions to call whenever the current
line changes.  Observers are called with one argument, <tt class="rst-docutils literal">self</tt>.
Cleared at the end of <code>run()</code>.</div> (type: <code>list</code>)
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="docutils.statemachine.StateMachine._stderr">
    
  </a>
  <a name="_stderr">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_stderr</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div>Wrapper around sys.stderr catching en-/decoding errors</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.unlink">
    
  </a>
  <a name="unlink">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">unlink</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Remove circular references to objects no longer required.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.run">
    
  </a>
  <a name="run">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">run</span>(self, input_lines, input_offset=0, context=None, input_source=None, initial_state=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="docutils.parsers.rst.states.NestedStateMachine.html">docutils.parsers.rst.states.NestedStateMachine</a></code>, <code><a href="docutils.parsers.rst.states.RSTStateMachine.html">docutils.parsers.rst.states.RSTStateMachine</a></code></div>
    
    <div><p>Run the state machine on <code><a href="#input_lines">input_lines</a></code>. Return results (a list).</p>
<p>Reset <code>self.line_offset</code> and <code>self.current_state</code>. Run the
beginning-of-file transition. Input one line at a time and check for a
matching transition. If a match is found, call the transition method
and possibly change the state. Store the context returned by the
transition method to be passed on to the next transition matched.
Accumulate the results returned by the transition methods in a list.
Run the end-of-file transition. Finally, return the accumulated
results.</p>
<p>Parameters:</p>
<ul class="rst-simple">
<li><code><a href="#input_lines">input_lines</a></code>: a list of strings without newlines, or <code><a href="docutils.statemachine.StringList.html">StringList</a></code>.</li>
<li><code><a href="#input_offset">input_offset</a></code>: the line offset of <code><a href="#input_lines">input_lines</a></code> from the beginning
of the file.</li>
<li><code>context</code>: application-specific storage.</li>
<li><code>input_source</code>: name or path of source of <code><a href="#input_lines">input_lines</a></code>.</li>
<li><code><a href="#initial_state">initial_state</a></code>: name of initial state.</li>
</ul>
</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.get_state">
    
  </a>
  <a name="get_state">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_state</span>(self, next_state=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return current state object; set it first if <code>next_state</code> given.</p>
<p>Parameter <code>next_state</code>: a string, the name of the next state.</p>
<p>Exception: <code><a href="docutils.statemachine.UnknownStateError.html">UnknownStateError</a></code> raised if <code>next_state</code> unknown.</p>
</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.next_line">
    
  </a>
  <a name="next_line">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">next_line</span>(self, n=1):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Load <code>self.line</code> with the <code>n</code>'th next line and return it.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.is_next_line_blank">
    
  </a>
  <a name="is_next_line_blank">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_next_line_blank</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Return 1 if the next line is blank or non-existant.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.at_eof">
    
  </a>
  <a name="at_eof">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">at_eof</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Return 1 if the input is at or past end-of-file.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.at_bof">
    
  </a>
  <a name="at_bof">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">at_bof</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Return 1 if the input is at or before beginning-of-file.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.previous_line">
    
  </a>
  <a name="previous_line">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">previous_line</span>(self, n=1):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Load <code>self.line</code> with the <code>n</code>'th previous line and return it.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.goto_line">
    
  </a>
  <a name="goto_line">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">goto_line</span>(self, line_offset):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Jump to absolute line offset <code><a href="#line_offset">line_offset</a></code>, load and return it.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.get_source">
    
  </a>
  <a name="get_source">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_source</span>(self, line_offset):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Return source of line at absolute line offset <code><a href="#line_offset">line_offset</a></code>.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.abs_line_offset">
    
  </a>
  <a name="abs_line_offset">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">abs_line_offset</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Return line offset of current line, from beginning of file.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.abs_line_number">
    
  </a>
  <a name="abs_line_number">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">abs_line_number</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Return line number of current line (counting from 1).</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.get_source_and_line">
    
  </a>
  <a name="get_source_and_line">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_source_and_line</span>(self, lineno=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return (source, line) tuple for current or given line number.</p>
<p>Looks up the source and line number in the <code>self.input_lines</code>
StringList instance to count for included source files.</p>
<p>If the optional argument <code>lineno</code> is given, convert it from an
absolute line number to the corresponding (source, line) pair.</p>
</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.insert_input">
    
  </a>
  <a name="insert_input">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">insert_input</span>(self, input_lines, source):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.get_text_block">
    
  </a>
  <a name="get_text_block">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_text_block</span>(self, flush_left=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Return a contiguous block of text.</p>
<p>If <code>flush_left</code> is true, raise <code><a href="docutils.statemachine.UnexpectedIndentationError.html">UnexpectedIndentationError</a></code> if an
indented line is encountered before the text block ends (with a blank
line).</p>
</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.check_line">
    
  </a>
  <a name="check_line">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">check_line</span>(self, context, state, transitions=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Examine one line of input for a transition match &amp; execute its method.</p>
<p>Parameters:</p>
<ul class="rst-simple">
<li><code>context</code>: application-dependent storage.</li>
<li><code>state</code>: a <code><a href="docutils.statemachine.State.html">State</a></code> object, the current state.</li>
<li><code><a href="docutils.statemachine.State.html#transitions">transitions</a></code>: an optional ordered list of transition names to try,
instead of <tt class="rst-docutils literal">state.transition_order</tt>.</li>
</ul>
<p>Return the values returned by the transition method:</p>
<ul class="rst-simple">
<li>context: possibly modified from the parameter <code>context</code>;</li>
<li>next state name (<code><a href="docutils.statemachine.State.html">State</a></code> subclass name);</li>
<li>the result output of the transition, a list.</li>
</ul>
<p>When there is no match, <tt class="rst-docutils literal">state.no_match()</tt> is called and its return
value is returned.</p>
</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.add_state">
    
  </a>
  <a name="add_state">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_state</span>(self, state_class):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Initialize &amp; add a <code>state_class</code> (<code><a href="docutils.statemachine.State.html">State</a></code> subclass) object.</p>
<p>Exception: <code><a href="docutils.statemachine.DuplicateStateError.html">DuplicateStateError</a></code> raised if <code>state_class</code> was already
added.</p>
</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.add_states">
    
  </a>
  <a name="add_states">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_states</span>(self, state_classes):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Add <code><a href="docutils.parsers.rst.states.html#state_classes">state_classes</a></code> (a list of <code><a href="docutils.statemachine.State.html">State</a></code> subclasses).</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.runtime_init">
    
  </a>
  <a name="runtime_init">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">runtime_init</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Initialize <code>self.states</code>.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.error">
    
  </a>
  <a name="error">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">error</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Report error details.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.attach_observer">
    
  </a>
  <a name="attach_observer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">attach_observer</span>(self, observer):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>The <code>observer</code> parameter is a function or bound method which takes two
arguments, the source and offset of the current line.</div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.detach_observer">
    
  </a>
  <a name="detach_observer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">detach_observer</span>(self, observer):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="docutils.statemachine.StateMachine.notify_observers">
    
  </a>
  <a name="notify_observers">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">notify_observers</span>(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for <a href="https://github.com/tristanlatr/apidocs/tree/main">docutils-0.17.1</a>, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 21.2.2 at 2021-06-27 19:13:34.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>