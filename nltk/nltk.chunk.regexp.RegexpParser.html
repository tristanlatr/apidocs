<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>nltk.chunk.regexp.RegexpParser</title>
    <meta name="generator" content="pydoctor 21.2.2"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          <a href="http://www.nltk.org/" class="projecthome">nltk-3.6.2</a> <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <form action="search-results.html" id="search-box-container">
          <div class="input-group">
            <input id="search-box" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" />
            <span class="input-group-btn">
              <button class="btn btn-default" type="submit" title="Search"><img src="fonts/search.svg" alt="Search!" /></button>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help!" /></a>
            </span>
          </div>
        </form>

        <div class="rst-admonition hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”:
                  <br /> <code>'+foo bar -baz'</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”:
                  <br /> <code>'foo*'</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all documents 
                  that contains "foo" in their full dotted name and with “bar” in any field:
                  <br /> <code>'+fullName:*foo* +bar'</code>

                  <p>
                    Possible fields: 'name', 'docstring', 'fullName'.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”:
                  <br /> <code>'foo~1'</code>
                </li>
            </ul>

          </p>
        </div>

      </div>


    </div>
  </div>

  <script>
 
    function toggleSearchHelpText() {
        document.body.classList.toggle("search-help-hidden");
    }
    // Init search and help text
    document.getElementById('search-box-container').style.display = 'block';
    document.getElementById('search-help-box').style.display = 'block';
    document.body.classList.add("search-help-hidden");

  </script>

</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="nltk.html">nltk</a></code><wbr></wbr>.<code><a href="nltk.chunk.html">chunk</a></code><wbr></wbr>.<code><a href="nltk.chunk.regexp.html">regexp</a></code><wbr></wbr>.<code><a href="nltk.chunk.regexp.RegexpParser.html">RegexpParser</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">RegexpParser</span>(<a href="nltk.chunk.api.ChunkParserI.html" title="nltk.chunk.api.ChunkParserI">ChunkParserI</a>): <a href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1133" class="sourceLink">(source)</a></code></p>
        <p><a href="classIndex.html#nltk.chunk.regexp.RegexpParser">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>A grammar based chunk parser.  <tt class="rst-docutils literal">chunk.RegexpParser</tt> uses a set of
regular expression patterns to specify the behavior of the parser.
The chunking of the text is encoded using a <tt class="rst-docutils literal">ChunkString</tt>, and
each rule acts by modifying the chunking in the <tt class="rst-docutils literal">ChunkString</tt>.
The rules are all implemented using regular expression matching
and substitution.</p>
<p>A grammar contains one or more clauses in the following form:</p>
<pre class="rst-literal-block">
NP:
  {&lt;DT|JJ&gt;}          # chunk determiners and adjectives
  }&lt;[\.VI].*&gt;+{      # strip any tag beginning with V, I, or .
  &lt;.*&gt;}{&lt;DT&gt;         # split a chunk at a determiner
  &lt;DT|JJ&gt;{}&lt;NN.*&gt;    # merge chunk ending with det/adj
                     # with one starting with a noun
</pre>
<p>The patterns of a clause are executed in order.  An earlier
pattern may introduce a chunk boundary that prevents a later
pattern from executing.  Sometimes an individual pattern will
match on multiple, overlapping extents of the input.  As with
regular expression substitution more generally, the chunker will
identify the first match possible, then continue looking for matches
after this one has ended.</p>
<p>The clauses of a grammar are also executed in order.  A cascaded
chunk parser is one having more than one clause.  The maximum depth
of a parse tree created by this chunk parser is the same as the
number of clauses in the grammar.</p>
<p>When tracing is turned on, the comment portion of a line is displayed
each time the corresponding pattern is applied.</p>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id129">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__init__">__init__</a></code></td>
    <td><span>Create a new chunk parser, from the given start state and set of chunk patterns.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__repr__">__repr__</a></code></td>
    <td><span></span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__str__">__str__</a></code></td>
    <td><span></span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#parse">parse</a></code></td>
    <td><span>Apply the chunk parser to this input.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_add_stage">_add_stage</a></code></td>
    <td><span>Helper function for __init__: add a new stage to the parser.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_read_grammar">_read_grammar</a></code></td>
    <td><span>Helper function for __init__: read the grammar if it is a string.</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_grammar">_grammar</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_loop">_loop</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_stages">_stages</a></code></td>
    <td><span>The list of parsing stages corresponding to the grammar</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_start">_start</a></code></td>
    <td><span>The start symbol of the grammar (the root node of
resulting trees)</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_trace">_trace</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <code><a href="nltk.chunk.api.ChunkParserI.html">ChunkParserI</a></code>:
          </p>
          <table class="children sortable" id="id130">
  
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="nltk.chunk.api.ChunkParserI.html#evaluate">evaluate</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="nltk.chunk.regexp.RegexpParser.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__init__</span>(self, grammar, root_label='S', loop=1, trace=0):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1175">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Create a new chunk parser, from the given start state
and set of chunk patterns.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">grammar:</span>str or list(RegexpChunkParser)</td><td class="fieldArgDesc">The grammar, or a list of RegexpChunkParser objects</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">root_label:</span>str or Nonterminal</td><td class="fieldArgDesc">The top node of the tree being created</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loop:</span>int</td><td class="fieldArgDesc">The number of times to run through the patterns</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trace:</span>int</td><td class="fieldArgDesc">The level of tracing that should be used when
parsing a text.  <tt class="rst-docutils literal">0</tt> will generate no tracing output;
<tt class="rst-docutils literal">1</tt> will generate normal tracing output; and <tt class="rst-docutils literal">2</tt> or
higher will generate verbose tracing output.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.chunk.regexp.RegexpParser.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__repr__</span>(self):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1279">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">str</td><td class="fieldArgDesc">a concise string representation of this <tt class="rst-docutils literal">chunk.RegexpParser</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.chunk.regexp.RegexpParser.__str__">
    
  </a>
  <a name="__str__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__str__</span>(self):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1286">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">str</td><td class="fieldArgDesc">a verbose string representation of this
<tt class="rst-docutils literal">RegexpParser</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.chunk.regexp.RegexpParser.parse">
    
  </a>
  <a name="parse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">parse</span>(self, chunk_struct, trace=None):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1255">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="nltk.chunk.api.ChunkParserI.html#parse">nltk.chunk.api.ChunkParserI.parse</a></code></div>
    
    <div>Apply the chunk parser to this input.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">chunk_struct:</span>Tree</td><td class="fieldArgDesc">the chunk structure to be (further) chunked
(this tree is modified, and is also returned)</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trace:</span>int</td><td class="fieldArgDesc">The level of tracing that should be used when
parsing a text.  <tt class="rst-docutils literal">0</tt> will generate no tracing output;
<tt class="rst-docutils literal">1</tt> will generate normal tracing output; and <tt class="rst-docutils literal">2</tt> or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">Tree</td><td class="fieldArgDesc">the chunked output.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.chunk.regexp.RegexpParser._add_stage">
    
  </a>
  <a name="_add_stage">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_add_stage</span>(self, rules, lhs, root_label, trace):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1243">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Helper function for __init__: add a new stage to the parser.</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.chunk.regexp.RegexpParser._read_grammar">
    
  </a>
  <a name="_read_grammar">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_read_grammar</span>(self, grammar, root_label, trace):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1213">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Helper function for __init__: read the grammar if it is a
string.</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.chunk.regexp.RegexpParser._grammar">
    
  </a>
  <a name="_grammar">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_grammar</span> =
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1194">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.chunk.regexp.RegexpParser._loop">
    
  </a>
  <a name="_loop">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_loop</span> =
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1195">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.chunk.regexp.RegexpParser._stages">
    
  </a>
  <a name="_stages">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_stages</span>: int =
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1170">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>The list of parsing stages corresponding to the grammar</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.chunk.regexp.RegexpParser._start">
    
  </a>
  <a name="_start">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_start</span>: str =
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1167">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>The start symbol of the grammar (the root node of
resulting trees)</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.chunk.regexp.RegexpParser._trace">
    
  </a>
  <a name="_trace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_trace</span> =
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/chunk/regexp.py#L1192">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for <a href="http://www.nltk.org/" class="projecthome">nltk-3.6.2</a>,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    21.2.2 at 2022-01-06 17:13:30.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>