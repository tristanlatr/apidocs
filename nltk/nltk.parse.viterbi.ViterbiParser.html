<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>nltk.parse.viterbi.ViterbiParser</title>
    <meta name="generator" content="pydoctor 22.2.2.dev0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          <a href="http://www.nltk.org/" class="projecthome">nltk-3.6.2</a> <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        <div>
          <span class="label label-default" id="search-docstrings-button">
            <a title="Search in docstrings" onclick="toggleSearchInDocstrings()">search in docstrings</a></span>
        </div>

        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>
        
        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>
  </div>

  <script src="ajax.js" type="text/javascript"></script>
  <script src="search.js" type="text/javascript"></script>

</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="index.html" class="internal-link">nltk</a></code><wbr></wbr>.<code><a href="nltk.parse.html" class="internal-link" title="nltk.parse">parse</a></code><wbr></wbr>.<code><a href="nltk.parse.viterbi.html" class="internal-link" title="nltk.parse.viterbi">viterbi</a></code><wbr></wbr>.<code><a href="nltk.parse.viterbi.ViterbiParser.html" class="internal-link" title="nltk.parse.viterbi.ViterbiParser">ViterbiParser</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">ViterbiParser</span>(<a href="nltk.parse.api.ParserI.html" class="internal-link" title="nltk.parse.api.ParserI">ParserI</a>): <a href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L19" class="sourceLink">(source)</a></code></p>
        <p><a href="classIndex.html#nltk.parse.viterbi.ViterbiParser">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>A bottom-up <tt class="rst-docutils literal">PCFG</tt> parser that uses dynamic programming to find
the single most likely parse for a text.  The <tt class="rst-docutils literal">ViterbiParser</tt> parser
parses texts by filling in a "most likely constituent table".
This table records the most probable tree representation for any
given span and node value.  In particular, it has an entry for
every start index, end index, and node value, recording the most
likely subtree that spans from the start index to the end index,
and has the given node value.</p>
<p>The <tt class="rst-docutils literal">ViterbiParser</tt> parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar's start
symbol.</p>
<p>In order to find the most likely constituent with a given span and
node value, the <tt class="rst-docutils literal">ViterbiParser</tt> parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production's right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.</p>
<p>A pseudo-code description of the algorithm used by
<tt class="rst-docutils literal">ViterbiParser</tt> is:</p>
<div class="rst-line-block">
<div class="rst-line">Create an empty most likely constituent table, <em>MLC</em>.</div>
<div class="rst-line">For width in 1...len(text):</div>
<div class="rst-line-block">
<div class="rst-line">For start in 1...len(text)-width:</div>
<div class="rst-line-block">
<div class="rst-line">For prod in grammar.productions:</div>
<div class="rst-line-block">
<div class="rst-line">For each sequence of subtrees [t[1], t[2], ..., t[n]] in MLC,</div>
<div class="rst-line-block">
<div class="rst-line">where t[i].label()==prod.rhs[i],</div>
<div class="rst-line">and the sequence covers [start:start+width]:</div>
<div class="rst-line-block">
<div class="rst-line">old_p = MLC[start, start+width, prod.lhs]</div>
<div class="rst-line">new_p = P(t[1])P(t[1])...P(t[n])P(prod)</div>
<div class="rst-line">if new_p &gt; old_p:</div>
<div class="rst-line-block">
<div class="rst-line">new_tree = Tree(prod.lhs, t[1], t[2], ..., t[n])</div>
<div class="rst-line">MLC[start, start+width, prod.lhs] = new_tree</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="rst-line">Return MLC[0, len(text), start_symbol]</div>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id1130">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__init__" class="internal-link" title="nltk.parse.viterbi.ViterbiParser.__init__">__init__</a></code></td>
    <td>Create a new <tt class="rst-docutils literal">ViterbiParser</tt> parser, that uses <tt class="rst-docutils literal">grammar</tt> to parse texts.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__repr__" class="internal-link" title="nltk.parse.viterbi.ViterbiParser.__repr__">__repr__</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#grammar" class="internal-link" title="nltk.parse.viterbi.ViterbiParser.grammar">grammar</a></code></td>
    <td></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#parse" class="internal-link" title="nltk.parse.viterbi.ViterbiParser.parse">parse</a></code></td>
    <td></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#trace" class="internal-link" title="nltk.parse.viterbi.ViterbiParser.trace">trace</a></code></td>
    <td>Set the level of tracing output that should be generated when parsing a text.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_add_constituents_spanning" class="internal-link" title="nltk.parse.viterbi.ViterbiParser._add_constituents_spanning">_add​_constituents​_spanning</a></code></td>
    <td>Find any constituents that might cover <tt class="rst-docutils literal">span</tt>, and add them to the most likely constituents table.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_find_instantiations" class="internal-link" title="nltk.parse.viterbi.ViterbiParser._find_instantiations">_find​_instantiations</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_match_rhs" class="internal-link" title="nltk.parse.viterbi.ViterbiParser._match_rhs">_match​_rhs</a></code></td>
    <td></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_trace_lexical_insertion" class="internal-link" title="nltk.parse.viterbi.ViterbiParser._trace_lexical_insertion">_trace​_lexical​_insertion</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_trace_production" class="internal-link" title="nltk.parse.viterbi.ViterbiParser._trace_production">_trace​_production</a></code></td>
    <td>Print trace output indicating that a given production has been applied at a given location.</td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_grammar" class="internal-link" title="nltk.parse.viterbi.ViterbiParser._grammar">_grammar</a></code></td>
    <td>The grammar used to parse sentences.</td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_trace" class="internal-link" title="nltk.parse.viterbi.ViterbiParser._trace">_trace</a></code></td>
    <td>The level of tracing output that should be generated
when parsing a text.</td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <code><a href="nltk.parse.api.ParserI.html" class="internal-link" title="nltk.parse.api.ParserI">ParserI</a></code>:
          </p>
          <table class="children sortable" id="id1131">
  
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="nltk.parse.api.ParserI.html#parse_all" class="internal-link" title="nltk.parse.api.ParserI.parse_all">parse​_all</a></code></td>
    <td></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="nltk.parse.api.ParserI.html#parse_one" class="internal-link" title="nltk.parse.api.ParserI.parse_one">parse​_one</a></code></td>
    <td></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="nltk.parse.api.ParserI.html#parse_sents" class="internal-link" title="nltk.parse.api.ParserI.parse_sents">parse​_sents</a></code></td>
    <td>Apply <tt class="rst-docutils literal">self.parse()</tt> to each element of <tt class="rst-docutils literal">sents</tt>. :rtype: iter(iter(Tree))</td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__init__</span>(self, grammar, trace=0):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L75">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Create a new <tt class="rst-docutils literal">ViterbiParser</tt> parser, that uses <tt class="rst-docutils literal">grammar</tt> to
parse texts.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">grammar:</span>PCFG</td><td class="fieldArgDesc">The grammar used to parse texts.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trace:</span>int</td><td class="fieldArgDesc">The level of tracing that should be used when
parsing a text.  <tt class="rst-docutils literal">0</tt> will generate no tracing output;
and higher numbers will produce more verbose tracing
output.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__repr__</span>(self):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L322">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.grammar">
    
  </a>
  <a name="grammar">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">grammar</span>(self):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L91">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="nltk.parse.api.ParserI.html#grammar" class="internal-link">nltk.parse.api.ParserI.grammar</a></code></div>
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">The grammar used by this parser.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.parse">
    
  </a>
  <a name="parse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">parse</span>(self, tokens):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L107">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="nltk.parse.api.ParserI.html#parse" class="internal-link">nltk.parse.api.ParserI.parse</a></code></div>
    
    <div>When possible this list is sorted from most likely to least likely.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">tokens</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sent:</span>list(str)</td><td class="fieldArgDesc">The sentence to be parsed</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">iter(Tree)</td><td class="fieldArgDesc">An iterator that generates parse trees for the sentence.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.trace">
    
  </a>
  <a name="trace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">trace</span>(self, trace=2):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L94">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Set the level of tracing output that should be generated when
parsing a text.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trace:</span>int</td><td class="fieldArgDesc">The trace level.  A trace level of <tt class="rst-docutils literal">0</tt> will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">None</td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._add_constituents_spanning">
    
  </a>
  <a name="_add_constituents_spanning">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_add_constituents_spanning</span>(self, span, constituents, tokens):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L150">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Find any constituents that might cover <tt class="rst-docutils literal">span</tt>, and add them
to the most likely constituents table.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">span:</span>tuple(int, int)</td><td class="fieldArgDesc">The section of the text for which we are
trying to find possible constituents.  The span is
specified as a pair of integers, where the first integer
is the index of the first token that should be included in
the constituent; and the second integer is the index of
the first token that should not be included in the
constituent.  I.e., the constituent should cover
<tt class="rst-docutils literal"><span class="pre">text[span[0]:span[1]]</span></tt>, where <tt class="rst-docutils literal">text</tt> is the text
that we are parsing.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">constituents:</span>dict(tuple(int,int,Nonterminal) -&gt; ProbabilisticToken or ProbabilisticTree)</td><td class="fieldArgDesc">The most likely constituents table.  This
table records the most probable tree representation for
any given span and node value.  In particular,
<tt class="rst-docutils literal">constituents(s,e,nv)</tt> is the most likely
<tt class="rst-docutils literal">ProbabilisticTree</tt> that covers <tt class="rst-docutils literal">text[s:e]</tt>
and has a node value <tt class="rst-docutils literal">nv.symbol()</tt>, where <tt class="rst-docutils literal">text</tt>
is the text that we are parsing.  When
<tt class="rst-docutils literal">_add_constituents_spanning</tt> is called, <tt class="rst-docutils literal">constituents</tt>
should contain all possible constituents that are shorter
than <tt class="rst-docutils literal">span</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">tokens:</span>list of tokens</td><td class="fieldArgDesc">The text we are parsing.  This is only used for
trace output.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">None</td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._find_instantiations">
    
  </a>
  <a name="_find_instantiations">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_find_instantiations</span>(self, span, constituents):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L218">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">span:</span>tuple(int, int)</td><td class="fieldArgDesc">The section of the text for which we are
trying to find production instantiations.  The span is
specified as a pair of integers, where the first integer
is the index of the first token that should be covered by
the production instantiation; and the second integer is
the index of the first token that should not be covered by
the production instantiation.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">constituents:</span>dict(tuple(int,int,Nonterminal) -&gt; ProbabilisticToken or ProbabilisticTree)</td><td class="fieldArgDesc">The most likely constituents table.  This
table records the most probable tree representation for
any given span and node value.  See the module
documentation for more information.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of the production instantiations that cover a
given span of the text.  A "production instantiation" is
a tuple containing a production and a list of children,
where the production's right hand side matches the list of
children; and the children cover <tt class="rst-docutils literal">span</tt>.  :rtype: list
of <tt class="rst-docutils literal">pair</tt> of <tt class="rst-docutils literal">Production</tt>, (list of
(<tt class="rst-docutils literal">ProbabilisticTree</tt> or token.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._match_rhs">
    
  </a>
  <a name="_match_rhs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_match_rhs</span>(self, rhs, span, constituents):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L250">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">rhs:</span>list(Nonterminal or any)</td><td class="fieldArgDesc">The list specifying what kinds of children need to
cover <tt class="rst-docutils literal">span</tt>.  Each nonterminal in <tt class="rst-docutils literal">rhs</tt> specifies
that the corresponding child should be a tree whose node
value is that nonterminal's symbol.  Each terminal in <tt class="rst-docutils literal">rhs</tt>
specifies that the corresponding child should be a token
whose type is that terminal.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">span:</span>tuple(int, int)</td><td class="fieldArgDesc">The section of the text for which we are
trying to find child lists.  The span is specified as a
pair of integers, where the first integer is the index of
the first token that should be covered by the child list;
and the second integer is the index of the first token
that should not be covered by the child list.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">constituents:</span>dict(tuple(int,int,Nonterminal) -&gt; ProbabilisticToken or ProbabilisticTree)</td><td class="fieldArgDesc">The most likely constituents table.  This
table records the most probable tree representation for
any given span and node value.  See the module
documentation for more information.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">list(list(ProbabilisticTree or token)</td><td class="fieldArgDesc">a set of all the lists of children that cover <tt class="rst-docutils literal">span</tt>
and that match <tt class="rst-docutils literal">rhs</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._trace_lexical_insertion">
    
  </a>
  <a name="_trace_lexical_insertion">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_trace_lexical_insertion</span>(self, token, index, width):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L317">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._trace_production">
    
  </a>
  <a name="_trace_production">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_trace_production</span>(self, production, p, span, width):
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L294">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Print trace output indicating that a given production has been
applied at a given location.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">production:</span>Production</td><td class="fieldArgDesc">The production that has been applied</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">p:</span>float</td><td class="fieldArgDesc">The probability of the tree produced by the production.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">span:</span>tuple</td><td class="fieldArgDesc">The span of the production</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">width</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">None</td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._grammar">
    
  </a>
  <a name="_grammar">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_grammar</span>: PCFG =
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L68">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>The grammar used to parse sentences.</div>
    
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._trace">
    
  </a>
  <a name="_trace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_trace</span>: int =
    <a class="sourceLink" href="https://github.com/nltk/nltk/tree/3.6.2/nltk/parse/viterbi.py#L70">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>The level of tracing output that should be generated
when parsing a text.</div>
    
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for <a href="http://www.nltk.org/" class="projecthome">nltk-3.6.2</a>,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.2.2.dev0 at 2022-03-04 05:57:24.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>