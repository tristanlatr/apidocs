<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>astroid.builder : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header navbar-brand">
          <a href="https://github.com/tristanlatr/apidocs/tree/main">astroid-v2.6.0</a>
          <a href="index.html">API Documentation</a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="astroid.html">astroid</a></code>.<code><a href="astroid.builder.html">builder</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p>The AstroidBuilder makes astroid from living object and / or from _ast</p>
<p>The builder is not thread safe and can't be used to parse different sources
at the same time.</p>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id79">
  
  <tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#objects">objects</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#MISPLACED_TYPE_ANNOTATION_ERROR">MISPLACED_TYPE_ANNOTATION_ERROR</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#open_source_file">open_source_file</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="astroid.builder.AstroidBuilder.html">AstroidBuilder</a></code></td>
    <td><span>Class for building an astroid tree from source code or from a live module.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#build_namespace_package_module">build_namespace_package_module</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#parse">parse</a></code></td>
    <td><span>Parses a source string in order to obtain an astroid AST from it</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#extract_node">extract_node</a></code></td>
    <td><span>Parses some Python code as a module and extracts a designated AST node.</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_TRANSIENT_FUNCTION">_TRANSIENT_FUNCTION</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_STATEMENT_SELECTOR">_STATEMENT_SELECTOR</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_can_assign_attr">_can_assign_attr</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_extract_expressions">_extract_expressions</a></code></td>
    <td><span>Find expressions in a call to _TRANSIENT_FUNCTION and extract them.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_find_statement_by_line">_find_statement_by_line</a></code></td>
    <td><span>Extracts the statement on a specific line from an AST.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_parse_string">_parse_string</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basevariable">
  
  <a name="astroid.builder.objects">
    
  </a>
  <a name="objects">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">objects</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basevariable private">
  
  <a name="astroid.builder._TRANSIENT_FUNCTION">
    
  </a>
  <a name="_TRANSIENT_FUNCTION">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_TRANSIENT_FUNCTION</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div> (type: <code>str</code>)
  </div>
</div><div class="basevariable private">
  
  <a name="astroid.builder._STATEMENT_SELECTOR">
    
  </a>
  <a name="_STATEMENT_SELECTOR">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_STATEMENT_SELECTOR</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div> (type: <code>str</code>)
  </div>
</div><div class="basevariable">
  
  <a name="astroid.builder.MISPLACED_TYPE_ANNOTATION_ERROR">
    
  </a>
  <a name="MISPLACED_TYPE_ANNOTATION_ERROR">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">MISPLACED_TYPE_ANNOTATION_ERROR</span> =
    
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div> (type: <code>str</code>)
  </div>
</div><div class="basefunction">
  
  <a name="astroid.builder.open_source_file">
    
  </a>
  <a name="open_source_file">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">open_source_file</span>(filename):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="astroid.builder._can_assign_attr">
    
  </a>
  <a name="_can_assign_attr">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_can_assign_attr</span>(node, attrname):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="astroid.builder.build_namespace_package_module">
    
  </a>
  <a name="build_namespace_package_module">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">build_namespace_package_module</span>(name, path):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="astroid.builder.parse">
    
  </a>
  <a name="parse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">parse</span>(code, module_name='', path=None, apply_transforms=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div>Parses a source string in order to obtain an astroid AST from it<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">code</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">module_name</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">path</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">apply_transforms</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">str code</td><td>The code for the module.</td></tr><tr><td></td><td class="fieldArg">str module_name</td><td>The name for the module, if any</td></tr><tr><td></td><td class="fieldArg">str path</td><td>The path for the module</td></tr><tr><td></td><td class="fieldArg">bool apply_transforms</td><td>Apply the transforms for the give code. Use it if you
don't want the default transforms to be applied.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="astroid.builder._extract_expressions">
    
  </a>
  <a name="_extract_expressions">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_extract_expressions</span>(node):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Find expressions in a call to _TRANSIENT_FUNCTION and extract them.</p>
<p>The function walks the AST recursively to search for expressions that
are wrapped into a call to _TRANSIENT_FUNCTION. If it finds such an
expression, it completely removes the function call node from the tree,
replacing it by the wrapped expression inside the parent.</p>
<p>expression can be found.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">node</td><td>An astroid node. (type: astroid.bases.NodeNG)</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: yields</td><td colspan="2">The sequence of wrapped expressions on the modified tree</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="astroid.builder._find_statement_by_line">
    
  </a>
  <a name="_find_statement_by_line">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_find_statement_by_line</span>(node, line):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Extracts the statement on a specific line from an AST.</p>
<p>If the line number of node matches line, it will be returned;
otherwise its children are iterated and the function is called
recursively.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">node</td><td>An astroid node. (type: astroid.bases.NodeNG)</td></tr><tr><td></td><td class="fieldArg">line</td><td>The line number of the statement to extract. (type: int)</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">The statement on the line, or None if no statement for the line
can be found. (type: astroid.bases.NodeNG or None)</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  <a name="astroid.builder.extract_node">
    
  </a>
  <a name="extract_node">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">extract_node</span>(code, module_name=''):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Parses some Python code as a module and extracts a designated AST node.</p>
<dl class="rst-docutils">
<dt>Statements:</dt>
<dd><p class="rst-first">To extract one or more statement nodes, append #@ to the end of the line</p>
<dl class="rst-last rst-docutils">
<dt>Examples:</dt>
<dd><blockquote class="rst-first">
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">x</span>():
<span class="py-prompt">&gt;&gt;&gt; </span>  <span class="py-keyword">def</span> <span class="py-defname">y</span>():
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">return</span> 1 <span class="py-comment">#@</span></pre><p>The return statement will be extracted.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">class</span> <span class="py-defname">X</span>(<span class="py-builtin">object</span>):
<span class="py-prompt">&gt;&gt;&gt; </span>  <span class="py-keyword">def</span> <span class="py-defname">meth</span>(self): <span class="py-comment">#@</span>
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">pass</span></pre></blockquote>
<p class="rst-last">The function object 'meth' will be extracted.</p>
</dd>
</dl>
</dd>
<dt>Expressions:</dt>
<dd><p class="rst-first">To extract arbitrary expressions, surround them with the fake
function call __(...). After parsing, the surrounded expression
will be returned and the whole AST (accessible via the returned
node's parent attribute) will look like the function call was
never there in the first place.</p>
<dl class="rst-last rst-docutils">
<dt>Examples:</dt>
<dd><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = __(1)</pre><p>The const node will be extracted.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">x</span>(d=__(foo.bar)): <span class="py-keyword">pass</span></pre><p>The node containing the default argument will be extracted.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">foo</span>(a, b):
<span class="py-prompt">&gt;&gt;&gt; </span>  <span class="py-keyword">return</span> 0 &lt; __(<span class="py-builtin">len</span>(a)) &lt; b</pre><p class="rst-last">The node containing the function call 'len' will be extracted.</p>
</dd>
</dl>
</dd>
</dl>
<p>If no statements or expressions are selected, the last toplevel
statement will be returned.</p>
<p>If the selected statement is a discard statement, (i.e. an expression
turned into a statement), the wrapped expression is returned instead.</p>
<p>For convenience, singleton lists are unpacked.</p>
<p>a module. Will be passed through textwrap.dedent first.
:param str module_name: The name of the module.
:returns: The designated node from the parse tree, or a list of nodes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">code</td><td><span class="undocumented">Undocumented</span> (type: <code>str</code>)</td></tr><tr><td></td><td class="fieldArg">module_name</td><td><span class="undocumented">Undocumented</span> (type: <code>str</code>)</td></tr><tr><td></td><td class="fieldArg">str code</td><td>A piece of Python code that is parsed as</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><span class="undocumented">Undocumented</span> (type: <code>Union[<a href="astroid.node_classes.NodeNG.html">NodeNG</a>, List[<a href="astroid.node_classes.NodeNG.html">NodeNG</a>]]</code>)</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="astroid.builder._parse_string">
    
  </a>
  <a name="_parse_string">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_parse_string</span>(data, type_comments=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for <a href="https://github.com/tristanlatr/apidocs/tree/main">astroid-v2.6.0</a>, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 21.2.2 at 2021-06-27 19:22:56.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>